\documentclass[lettersize,journal]{IEEEtran}
\usepackage{amsmath, amsfonts}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{array}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\usepackage{textcomp}
\usepackage{stfloats}
\usepackage{url}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{cite}
\hyphenation{}

\begin{document}

\title{\texttt{quadcopter} package}
\author{dinay-kingkiller}

\maketitle

%\begin{abstract}
%\end{abstract}

\section{Introduction}
\IEEEPARstart{T}{he} \texttt{quadcopter} package is filled with obtuse and often confusing code derived from various physics equations and mathematical formulas.
This paper hopes to bridge the gap between quadcopter theory and the \texttt{src} files included. 
This paper can also be used as a reference for later expansion of this package.

\section{The Model Node}
While an actual quadcopter would be helpful, a simulation is the next best thing.
The model node simulates the physics of a quadcopter.
The physics in this section also provide insight on how motor input and sensor output behave.

\subsection{Rotational Kinematics}
Quaternions are integral in understanding the implementation of the model node.
Derivations of quaternion operations can be found elsewhere, including on my GitHub.
This paper will then focus on the implementation in the model node.
There are multiple definitions for quaternion multiplication.
The model node uses the same definition as the \texttt{tf2} ROS package.
\begin{equation}
    \begin{pmatrix}
      x_1 \\
      y_1 \\
      z_1 \\
      w_1
    \end{pmatrix} \otimes 
    \begin{pmatrix}
      x_2 \\
      y_2 \\
      z_2 \\
      w_2
    \end{pmatrix} =
    \begin{pmatrix}
      w_1x_2 + x_1w_2 + y_1z_2 - z_1y_2 \\
      w_1y_2 - x_1z_2 + y_1w_2 + z_1x_2 \\
      w_1z_2 + x_1y_2 - y_1x_2 + z_1w_2 \\
      w_1w_2 - x_1x_2 - y_1y_2 - z_1z_2
    \end{pmatrix}
\end{equation}
The unit quaternion $\mathrm{q}$ describes the orientation of the robot by describing a transform between two frames
\begin{equation}
	\begin{pmatrix}
	\mathbf{v}^B \\
	0
	\end{pmatrix}
	= \mathrm{q} \otimes
	\begin{pmatrix}
	  \mathbf{v}^N \\
		0
	\end{pmatrix}
		\mathrm{q}^* 
\end{equation}
where $\mathbf{v}^N$ and $\mathbf{v}^B$ are the same vector described in an inertial frame $N$ and the robot body frame $B$ respectively.
A rotation matrix is another description of rotations:
\begin{equation}
	\mathbf{v}^B = \mathrm{R}\left(\mathbf{v}^N\right)
\end{equation}
Importantly for the model node, rotation matrices collect the dot product of basis vectors: $\mathrm{R}_{ij} = \mathbf{\hat{b}}_i \cdot \mathbf{\hat{n}}_j$. In terms of quaternion $(x, y, z, w)$
\begin{equation}
	\mathrm{R}=\left(
	\begin{smallmatrix}
		x^2-y^2-z^2+w^2 & 2xy-2zw & 2xz+2yw \\
    2xy+2zw & -x^2+y^2-z^2+w^2 & -2xw+2yz \\
    2xz-2wy & 2xw+2yz & -x^2-y^2+z^2+w^2
	\end{smallmatrix} 
	\right) \label{EQN:RotationMatrix}
\end{equation}
That rate of change of the quaternion can be calculated from the angular velocity
\begin{equation}
	\mathrm{\dot{q}} = \frac{1}{2}
	\begin{pmatrix}
	  \boldsymbol\omega \\
		0
	\end{pmatrix}
	\otimes \mathrm{q}
\end{equation}
where $\boldsymbol\omega$ is the angular velocity of the robot body $B$ in the inertial frame $N$ described in the body basis:
\begin{equation}
	\boldsymbol\omega = \omega_x \mathbf{\hat{b}}_x + \omega_y \mathbf{\hat{b}}_y + \omega_z \mathbf{\hat{b}}_z \label{EQN:AngularVelocity}
\end{equation}
Currently the model node uses a linear interpolation
\begin{equation}
	\mathrm{q}[k+1] = \mathrm{q}[k] + 
		\begin{pmatrix}
		\boldsymbol\omega[k] \\
		0
	\end{pmatrix} \otimes
	\mathrm{q}[k] \Delta t
\end{equation}
Or 
\begin{equation}
	\frac{\Delta \mathrm{q}}{\Delta t} =
	\begin{pmatrix}
	-\omega_z q_y + \omega_y q_z + \omega_x q_w \nonumber \\
  \omega_z q_x - \omega_x q_z + \omega_y q_w \nonumber \\
  -\omega_y q_x + \omega_x q_y + \omega_z q_w \nonumber \\
  - \omega_x q_x - \omega_y q_y - \omega_z q_z
	\end{pmatrix}
\end{equation}
This most simple integration method (Euler's Method) is fast to implement, but More accurate methods like Runge-Kutta or Crouch-Grossman could improve the accuracy. However they shouldn't be unneeded. Those algorithms can be more computationally intensive, and it's just a model.

\subsection{Linear Equations of Motion}
If you choose the right reference frames the linear equations of motion are easy to express. First, the motion of the quadcopter from its origin point is defined simply:
\begin{eqnarray}
  \mathbf{r}^N_c &=& r_x \mathbf{\hat{n}}_x + r_y \mathbf{\hat{n}}_y + r_z \mathbf{\hat{n}}_z \\
  \mathbf{v}^N_c &=& \dot{r}_x \mathbf{\hat{n}}_x + \dot{r}_y \mathbf{\hat{n}}_y + \dot{r}_z \mathbf{\hat{n}}_z \\
  \mathbf{a}^N_c &=& \ddot{r}_x \mathbf{\hat{n}}_x + \ddot{r}_y \mathbf{\hat{n}}_y + \ddot{r}_z \mathbf{\hat{n}}_z
\end{eqnarray}
For our model we assume each motor puts out a force proportional to its square.
If we let $m$ be the total mass of the robot and $k$ be the proportionality constant:
\begin{equation}
  m\mathbf{a}^N_c = k \left(\omega_f^2 + \omega_l^2 + \omega_b^2 + \omega_r^2\right) \mathbf{\hat{c}}_y - mg \mathbf{\hat{n}}_y
\end{equation}
Where $f$, $l$, $b$, and $r$ stand for the front, right, back and left motors respectively. 
By converting to the dot product via equation \ref{EQN:RotationMatrix}
\begin{eqnarray}
  \ddot{r}_x &=& 2Tq_xq_y+2Tq_zq_w \\
  \ddot{r}_y &=& -Tx^2+Ty^2-Tz^2+Tw^2 - g\\
  \ddot{r}_z &=& -2Tq_xq_w+2Tq_yq_z 
\end{eqnarray}
where $T$ is the specific motor thrust
\begin{equation}
	T = \frac{k}{m}\left(\omega_f^2 + \omega_l^2 + \omega_b^2 + \omega_r^2\right)
\end{equation}

\subsection{Rotational Equations of Motion}
Supposing that most of the mass of the quadcopter is in the motors, the inertia dyadics for the four motors is:
\begin{eqnarray}
  \mathbf{I}^{f/c} &=& \frac{mL^2}{4} \mathbf{\hat{c}}_y\mathbf{\hat{c}}_y + \frac{mL^2}{4} \mathbf{\hat{c}}_z \mathbf{\hat{c}}_z \\
  \mathbf{I}^{l/c} &=& \frac{mL^2}{4} \mathbf{\hat{c}}_x\mathbf{\hat{c}}_x + \frac{mL^2}{4} \mathbf{\hat{c}}_z \mathbf{\hat{c}}_z \\
  \mathbf{I}^{b/c} &=& \frac{mL^2}{4} \mathbf{\hat{c}}_y\mathbf{\hat{c}}_y + \frac{mL^2}{4} \mathbf{\hat{c}}_z \mathbf{\hat{c}}_z \\
  \mathbf{I}^{r/c} &=& \frac{mL^2}{4} \mathbf{\hat{c}}_x\mathbf{\hat{c}}_x + \frac{mL^2}{4} \mathbf{\hat{c}}_z \mathbf{\hat{c}}_z
\end{eqnarray}
The total inertial dyadic of the robot is then
\begin{equation}
  \mathbf{I}^{R/c} = \frac{mL^2}{2} \left(\mathbf{\hat{c}}_x\mathbf{\hat{c}}_x + \mathbf{\hat{c}}_y\mathbf{\hat{c}}_y + 2 \mathbf{\hat{c}}_z\mathbf{\hat{c}}_z\right)
\end{equation}
The angular velocity was given in \ref{EQN:AngularVelocity}, and the angular acceleration is just the derivative
\begin{align}
  {\boldsymbol\omega^N_B} &= \omega_x\mathbf{\hat{b}}_x + \omega_y\mathbf{\hat{b}}_y + \omega_c \mathbf{\hat{b}}_z \nonumber \\
	{\boldsymbol\alpha^N_B} &= \dot\omega_x\mathbf{\hat{b}}_x + \dot\omega_y\mathbf{\hat{b}}_y + d\dot\omega_c \mathbf{\hat{b}}_z
\end{align}
And the angular momentum is the dot product of the two
\begin{eqnarray}
  {^\mathrm{N}\mathbf{H}^{R/c}} &=& \mathbf{I}^{R/c} \cdot {_\mathrm{N}\boldsymbol\omega_\mathrm{C}}\nonumber\\
  &=&\frac{mL^2}{4}\left(\dot{a} \cos b \cos c - \dot{b} \sin c\right) \mathbf{\hat{c}}_x\nonumber\\
  &&+\frac{mL^2}{4}\left(\dot{a} \cos b \sin c + \dot{b} \cos c\right) \mathbf{\hat{c}}_y\nonumber\\
  &&+\frac{mL^2}{4}\left(\dot{a}\sin b + 2\dot{c}\right) \mathbf{\hat{c}}_z
\end{eqnarray}


The angular acceleration (in the inertial frame) can be found with some manipulation of derivatives in reference frames.
\begin{eqnarray}
  {_\mathrm{N}\boldsymbol\alpha_\mathrm{C}} &=& \frac{^\mathrm{N}\mathrm{d}}{\mathrm{d}t} {_\mathrm{N}\boldsymbol\omega_\mathrm{C}} \nonumber\\
  &=& \frac{^\mathrm{N}\mathrm{d}}{\mathrm{d}t} \dot{a} \mathbf{\hat{n}}_x + \frac{^\mathrm{A}\mathrm{d}}{\mathrm{d}t} \dot{b} \mathbf{a}_y + {_\mathrm{N}\boldsymbol\omega_\mathrm{A}} \times \dot{b} \mathbf{\hat{a}}_y\nonumber\\
  && + \frac{^\mathrm{B}\mathrm{d}}{\mathrm{d} t} \dot{c} \mathbf{\hat{b}}_z + {_\mathrm{N}\boldsymbol\omega_\mathrm{B}} \times \dot{c} \mathbf{\hat{b}}_z \nonumber\\
  &=& \ddot{a}\mathbf{\hat{n}}_x + \ddot{b} \mathbf{\hat{a}}_y + \ddot{c} \mathbf{\hat{c}}_z\nonumber\\
  &&+\dot{a}\dot{b}\mathbf{\hat{a}}_z + \dot{b}\dot{c} \mathbf{\hat{b}}_x + \dot{a}\dot{c} \left(\mathbf{\hat{n}}_x \times \mathbf{\hat{c}}_z\right) 
\end{eqnarray}

The moment from the reference frame $\mathbf{M}^* = \mathbf{I}\cdot \boldsymbol\alpha + \boldsymbol\omega\times \mathbf{H}$ was calculated with a script
\begin{eqnarray}
  \mathbf{M}^* \cdot \mathbf{\hat{c}}_x &=& \ddot{a}\cos b\cos c + \ddot{b}\sin c- \dot{a}\dot{b}\sin b\cos c\nonumber\\
  &&- \dot{a}\dot{c}\sin c\cos b + \dot{b}\dot{c}\cos c\\
  \mathbf{M}^* \cdot \mathbf{\hat{c}}_y &=& - \ddot{a}\sin c\cos b + \ddot{b}\cos c+\dot{a}\dot{b}\sin b\sin c\nonumber\\
  &&- \dot{a}\dot{c}\cos b\cos c - \dot{b}\dot{c}\sin c \\
  \mathbf{M}^* \cdot \mathbf{\hat{c}}_z &=& \ddot{a} \sin b + \ddot{c} +\dot{a} \dot{b} \cos b
\end{eqnarray}



% \section*{Acknowledgments}

{\appendix[Quaternion Kinematics]
Quadcopters hover, and rotate, and strafe, and sometimes flip.
Its important to track any of these movements smoothly, and hopefully without adding code to handle edge cases.
Quaternions are one such valuable representation.
}

%{\appendix[Proof of Zonklar Equations]
%Use $\backslash${\tt{appendix}} if you have a single appendix:
% Do not use $\backslash${\tt{section}} anymore after $\backslash${\tt{appendix}}, only $\backslash${\tt{section*}}.
% If you have multiple appendixes use $\backslash${\tt{appendices}} then use $\backslash${\tt{section}} to start each appendix.
%You must declare a $\backslash${\tt{section}} before using any $\backslash${\tt{subsection}} or using $\backslash${\tt{label}} ($\backslash${\tt{appendices}} by itself starts a section numbered zero.)}

%{\appendices
%\section*{Proof of the First Zonklar Equation}
%Appendix one text goes here.
% You can choose not to have a title for an appendix if you want by leaving the argument blank
%\section*{Proof of the Second Zonklar Equation}
%Appendix two text goes here.}



% \begin{thebibliography}{1}
% \bibliographystyle{IEEEtran}


%\end{thebibliography}



% \vfill

\end{document}
